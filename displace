#!/usr/bin/python3

import argparse
import math
import os
import time

from backend import xrandr, output_port_infos
from edid import info2edid, edid2ident, edid2size
from cfghelper import DesktopSetup as DESK
from cfghelper import OutputSetup as OUT
from config import postexec_all, defined_setups


def output_matches(info, ident):
    """does the specified info match the given identifiers?"""
    known = edid2ident(info2edid(info))
    if known is None:
        return False
    if not isinstance(ident, list):
        ident = [ident]
    intersect = [x for x in ident if x in known]
    return len(intersect) > 0


def get_outputs(infs):
    """return a description of all available outputs with connected monitors"""
    return [(port["name"], edid2ident(info2edid(port))) for port in infs]


def inf4ident(infs, ident, allow_disconnected=False):
    """retrieve port name for given identifier.

    unless @allow_disconnected, only ports with a connection are searched.
    """
    for port in infs:
        if ident == port["name"]:
            if allow_disconnected or port["available_resolutions"]:
                return port
        if output_matches(port, ident):
            if allow_disconnected or port["available_resolutions"]:
                return port
    return None


def port4ident(infs, ident, allow_disconnected=False):
    """retrieve port name for given identifier.

    unless @allow_disconnected, only ports with a connection are searched.
    """
    i = inf4ident(infs, ident, allow_disconnected)
    return i["name"] if i is not None else None


def filter_valid_setups(infs, setups):
    valid = []
    for setup in setups:
        for output in setups[setup].outputs:
            if inf4ident(infs, output.name) is None:
                break
        else:
            valid.append(setup)
    return valid


def apply_all_off(infs, dry=False):
    args = []
    for port in infs:
        args.append("--output")
        args.append(port["name"])
        args.append("--off")
    xrandr(*args, dry=dry)


def max_area_mode(modes):
    m = (0, 0)
    for mode in modes:
        if mode[0]*mode[1] > m[0]*m[1]:
            m = mode
    return m


def max_width_mode(modes):
    m = (0, 0)
    for mode in modes:
        if mode[0] > m[0] or mode[0] == m[0] and mode[1] > m[1]:
            m = mode
    return m


def apply_setup(infs, setup, dry=False):
    apply_all_off(infs, dry=dry)
    previous_port = None
    outputs = {}

    # prepare and validate settings, rescale to 0x0
    for output in setup.outputs:
        inf = inf4ident(infs, output.name)

        cfg = {}
        cfg["port"] = port4ident(infs, output.name)
        cfg["scale"] = output.scale
        cfg["rotate"] = output.rotation
        cfg["primary"] = output.primary

        cfg["location"] = output.location
        if isinstance(cfg["location"][0], str):
            if cfg["location"][1] == "previous":
                cfg["location"] = (cfg["location"][0], previous_port)
            cfg["location"] = (cfg["location"][0],
                               port4ident(infs, cfg["location"][1]))
            if cfg["location"][1] is None:
                raise TypeError("invalid location '{}'".format(
                                                output.get("location", None)))
        cfg["mode"] = output.mode
        if cfg["mode"] == "max_area":
            cfg["mode"] = max_area_mode(inf["available_resolutions"])
        elif cfg["mode"] == "max_width":
            cfg["mode"] = max_width_mode(inf["available_resolutions"])
        elif not isinstance(cfg["mode"], tuple):
            raise TypeError("invalid mode '{}'".format(cfg["mode"]))

        outputs[cfg["port"]] = cfg
        previous_port = cfg["port"]

    # translate given locations to absolute positions
    unresolved = True
    while unresolved:
        unresolved = False
        changed = False
        for (output, cfg) in outputs.items():
            if isinstance(cfg["location"][0], str):
                other = outputs[cfg["location"][1]]
                if isinstance(other["location"][0], str):
                    unresolved = True
                else:
                    w, h = cfg["mode"]
                    w = int(w * cfg["scale"][0])
                    h = int(h * cfg["scale"][1])
                    if cfg["rotate"] in ("left", "right"):
                        h, w = w, h

                    ox, oy = other["location"]
                    ow, oh = other["mode"]
                    ow = int(ow * other["scale"][0])
                    oh = int(oh * other["scale"][1])
                    if other["rotate"] in ("left", "right"):
                        oy, ox = ox, oy
                        oh, ow = ow, oh

                    if cfg["location"][0] == "left-of":
                        x = ox - w
                        y = oy
                    elif cfg["location"][0] == "right-of":
                        x = ox + ow
                        y = oy
                    elif cfg["location"][0] == "above":
                        x = ox
                        y = oy - h
                    elif cfg["location"][0] == "below":
                        x = ox
                        y = oy + oh
                    else:
                        raise ValueError("unknown relative location {}".format(
                                         cfg["location"]))
                    cfg["location"] = (x, y)
                    changed = True

        if unresolved and not changed:
            print(outputs)
            raise ValueError("unable to resolve relative positioning:")

    # normalize to (0, 0)
    offset_x = min((cfg["location"][0] for cfg in outputs.values()))
    offset_y = min((cfg["location"][1] for cfg in outputs.values()))
    for (port, cfg) in outputs.items():
        cfg["location"] = (cfg["location"][0] - offset_x,
                           cfg["location"][1] - offset_y)

    # identify framebuffer size
    # FIXME? seems to be optional.

    # actually configure displays
    for (port, cfg) in outputs.items():
        args = ["--output", cfg["port"],
                "--scale", "{}x{}".format(*cfg["scale"]),
                "--rotate", cfg["rotate"],
                "--pos", "{}x{}".format(cfg["location"][0],
                                        cfg["location"][1]),
                "--mode", "{}x{}".format(cfg["mode"][0],
                                         cfg["mode"][1]),
                ]

        if cfg["primary"]:
            args += ["--primary"]

        xrandr(*args, dry=dry)

    if not dry:
        time.sleep(.5)
    # execute any registered postexec things
    for cmd in postexec_all + setup.postexec:
        print("EXEC {}".format(cmd))
        if not dry:
            os.system(cmd)


def res(w, h):
    if w == 0 or h == 0:
        return "off"
    return "{}x{}".format(w, h)


def ratio16(w, h):
    """Aspect ratio of resolution, normalized to 16:x."""
    if w == 0 or h == 0:
        return "off"
    if w > h:
        return "16:" + str(round(16/w*h, 1)).replace(".0", "")
    else:
        return str(round(16/h*w, 1)).replace(".0", "") + ":16"


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Display placer")
    parser.add_argument("selection", nargs='?')
    parser.add_argument("-a", "--auto", action="store_true",
                        help="try to pick a good choice")
    parser.add_argument("-f", "--fallback", action="store_true",
                        help="add a screen-maxing fallback configuration")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="show additional diagnostic and info")
    parser.add_argument("-V", "--veryverbose", action="store_true",
                        help="show all diagnostic and info")
    parser.add_argument("-d", "--dry", action="store_true",
                        help="only show what would be executed")
    args = parser.parse_args()
    verbose = args.verbose or args.veryverbose
    veryverbose = args.veryverbose

    infs = output_port_infos()

    if args.fallback:
        valid_outputs = sorted([inf for inf in infs
                                if len(inf["available_resolutions"]) > 0],
                               key=lambda i: i["name"])
        if len(valid_outputs) > 0:
            fb = DESK(OUT(valid_outputs[0]["name"], primary=True),
                      *[OUT(out["name"], location=("right-of", "previous"))
                        for out in valid_outputs[1:]],
                      postexec=[])
            defined_setups["FALLBACK"] = fb

    valid_setups = filter_valid_setups(infs, defined_setups)

    if args.selection is None and not args.auto:
        print("available ports:")
        for (port, display) in get_outputs(infs):
            if display:
                inf = inf4ident(infs, port, allow_disconnected=True)
                physsize = edid2size(info2edid(inf))
                if physsize:
                    widthcm, heightcm = physsize
                    diagonalcm = math.sqrt(widthcm*widthcm+heightcm*heightcm)
                    diagonalinch = diagonalcm/2.54
                    diagonaltxt = '%.1f" ' % (diagonalinch)
                else:
                    diagonaltxt = ''
                mode = res(*inf["resolution"])
                print(" - {port}, {mode} ({ratio}), ".format(
                              port=port,
                              ratio=ratio16(*inf["resolution"]),
                              mode=mode,)
                      + "connected to {diagonaltxt}{display}".format(
                              diagonaltxt=diagonaltxt,
                              display=display if verbose else display[0]))
                if verbose:
                    print("   has modes and ratios:")
                    for (w, h) in sorted(inf["available_resolutions"],
                                         key=lambda m: m[0]*m[1],
                                         reverse=True):
                        if physsize:
                            dpi = "{}dpi".format(int(math.sqrt(w*w+h*h)/
                                                     diagonalinch))
                        else:
                            dpi = ""
                        print("     %-10s  %-10s %-10s" % (res(w, h),
                                                           ratio16(w, h),
                                                           dpi))
            else:
                print(" - {}".format(port))
        print()
        print("currently valid selections, in order of priority:")
        for s in valid_setups:
            print(" - {}".format(s))
            if verbose:
                print("    {}".format(defined_setups[s]))
        if args.veryverbose:
            print()
            print("currently invalid setups:")
            for s in defined_setups:
                if s not in valid_setups:
                    print(" - {}".format(s))
                    print("    {}".format(defined_setups[s]))
            print()
            if postexec_all:
                print("global postexec:")
                for p in postexec_all:
                    print("\t{}".format(p))
    else:
        if args.selection and args.auto:
            parser.error("cannot --auto and select")

        selection = args.selection
        if args.auto:
            valid_setups = filter_valid_setups(infs, defined_setups)
            if valid_setups:
                selection = valid_setups[0]

        if selection not in defined_setups:
            parser.error("{} is not a known setup".format(selection))
        if selection not in valid_setups:
            parser.error("{} is currently not a valid setup".format(selection))

        print("picked configuration: {}".format(selection))
        if verbose:
            print(defined_setups[selection])
        apply_setup(infs, defined_setups[selection], dry=args.dry)
